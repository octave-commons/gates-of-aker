# Task

We want to keep clojure functions simple using a linting metric similar to sonarqube's cognative complexity metric

## Caveats

* Sonar’s *Cognitive Complexity* rule (the “reduce from 26 to 15 allowed” thing) is a SonarSource metric based on “breaks linear reading flow” + “nesting adds extra weight.” ([simona.ie3.e-technik.tu-dortmund.de][1])
* SonarLint / “SonarQube for IDE” doesn’t list Clojure among its supported languages, and SonarCloud doesn’t support bringing your own language plugin. ([Visual Studio Marketplace][2])

So: to get *instant* feedback in **Emacs via clojure-lsp**, you’ll want to implement a **custom linter that emits LSP diagnostics**.

---

## Recommended: clojure-lsp custom linter that flags high Cognitive Complexity

clojure-lsp supports project-defined custom linters via `.lsp/config.edn`, and it will load the linter implementation from `clojure-lsp.exports/linters/...`. ([Clojure LSP][3])

### 1) Configure the linter in `.lsp/config.edn`

```clojure
{:linters
 {:custom
  {promethean.lint.cognitive-complexity/lint
   {:level :warning
    :max 15
    :count-boolean-ops? false}}}}
```

* `:max` is your threshold (like ESLint’s).
* flip `:level` to `:error` if you want agents to “feel pain” immediately.

### 2) Add the linter implementation file

Create:

`clojure-lsp.exports/linters/promethean/lint/cognitive_complexity.clj`

```clojure
(ns promethean.lint.cognitive-complexity
  (:require
    [clojure-lsp.custom-linters-api :as api]
    [rewrite-clj.zip :as z]))

;; Sonar-ish: +1 when flow breaks, +nesting weight for deeper blocks.
;; Not a byte-for-byte clone of Sonar; it's tuned for Clojure idioms (cond, try/catch, etc).

(def ^:private default-max 15)

(def ^:private branching-heads
  '#{if if-not if-let if-some
     when when-not when-let when-some
     for doseq dotimes while loop
     case cond condp
     try})

(defn- cc*
  [form nesting {:keys [count-boolean-ops?] :as opts}]
  (cond
    (seq? form)
    (let [head (first form)
          tail (rest form)]
      (cond
        ;; cond behaves like an if/elseif chain:
        ;; + (1+nesting) once, +1 per extra clause, bodies considered nested.
        (= head 'cond)
        (let [pairs        (partition-all 2 tail)
              clause-count (count pairs)
              structural   (+ (inc nesting) (max 0 (dec clause-count)))
              children     (reduce +
                                  (for [[test expr] pairs]
                                    (+ (cc* test nesting opts)
                                       (cc* expr (inc nesting) opts))))]
          (+ structural children))

        ;; case is switch-like: + (1+nesting) once, cases don't add structural cost.
        (= head 'case)
        (let [children (reduce + (map #(cc* % (inc nesting) opts) tail))]
          (+ (inc nesting) children))

        ;; try/catch: + (1+nesting) for try, +1 per catch (Sonar counts catch),
        ;; bodies considered nested.
        (= head 'try)
        (let [[body tail2] (split-with #(not (and (seq? %) (#{'catch 'finally} (first %))))
                                       tail)
              catches      (filter #(and (seq? %) (= 'catch (first %))) tail2)
              finally      (first (filter #(and (seq? %) (= 'finally (first %))) tail2))
              body-cc      (reduce + (map #(cc* % (inc nesting) opts) body))
              catches-cc   (reduce +
                                  (for [c catches]
                                    (let [[_ _ _ & cbody] c]     ;; (catch Exception e body...)
                                      (+ 1 (reduce + (map #(cc* % (inc nesting) opts) cbody))))))
              finally-cc   (if finally
                             (let [[_ & fbody] finally]
                               (reduce + (map #(cc* % (inc nesting) opts) fbody)))
                             0)]
          (+ (inc nesting) body-cc catches-cc finally-cc))

        ;; Optional: count boolean-chains (and/or) like Sonar does for && / ||.
        (and count-boolean-ops? (#{'and 'or} head))
        (let [ops    (max 0 (dec (count tail)))
              nested (reduce + (map #(cc* % nesting opts) tail))]
          (+ ops nested))

        ;; General branching: + (1+nesting), then analyze children as nested.
        (contains? branching-heads head)
        (let [structural (inc nesting)
              nested     (reduce + (map #(cc* % (inc nesting) opts) tail))]
          (+ structural nested))

        ;; Default: walk the whole list at same nesting
        :else
        (reduce + (map #(cc* % nesting opts) form))))

    (vector? form) (reduce + (map #(cc* % nesting opts) form))
    (map? form)    (reduce + (map (fn [[k v]] (+ (cc* k nesting opts) (cc* v nesting opts))) form))
    (set? form)    (reduce + (map #(cc* % nesting opts) form))
    :else 0))

(defn- strip-doc+attr [xs]
  (let [xs (if (string? (first xs)) (next xs) xs)
        xs (if (map? (first xs))    (next xs) xs)]
    xs))

(defn- strip-prepost [body]
  ;; defn arity can start with {:pre [...], :post [...]} — ignore it for complexity.
  (if (and (seq body)
           (map? (first body))
           (or (contains? (first body) :pre) (contains? (first body) :post)))
    (rest body)
    body))

(defn- arities->bodies [xs]
  (let [xs (strip-doc+attr xs)
        a0 (first xs)]
    (cond
      ;; single arity: [args] body...
      (vector? a0)
      [{:args a0 :body (strip-prepost (rest xs))}]

      ;; multi arity: ([args] body...) ([args2] body2...)
      (and (seq? a0) (vector? (first a0)))
      (->> xs
           (filter seq?)
           (map (fn [arity-form]
                  {:args (first arity-form)
                   :body (strip-prepost (rest arity-form))})))

      :else
      [])))

(defn- defn->info [form]
  (let [[_ name & more] form]
    {:name   name
     :meta   (meta name)
     :bodies (arities->bodies more)}))

(defn- threshold [params name-sym]
  (or (some-> (meta name-sym) :cognitive-complexity/max)
      (:max params)
      default-max))

(defn- ignored? [params name-sym]
  (true? (some-> (meta name-sym) :cognitive-complexity/ignore)))

(defn lint [{:keys [db uris params reg-diagnostic!]}]
  (let [uris (api/dir-uris->file-uris uris db)
        db   (api/db-with-uris-analysis db uris)
        defined-bys #{'clojure.core/defn 'clojure.core/defn-}]
    (doseq [uri uris
            :let [elements (api/find-var-definitions db uri true)
                  nodes    (api/find-nodes db elements #(contains? defined-bys (:defined-by %)))]]
      (doseq [loc nodes
              :let [form               (z/sexpr loc)
                    {:keys [name bodies]} (defn->info form)]
              :when (and (symbol? name) (seq bodies) (not (ignored? params name)))]
        (let [opts        {:count-boolean-ops? (boolean (:count-boolean-ops? params))}
              score       (apply max 0 (for [{:keys [body]} bodies]
                                        (reduce + (map #(cc* % 0 opts) body))))
              max-allowed (threshold params name)]
          (when (> score max-allowed)
            ;; rewrite-clj preserves positional metadata on sexprs, which clojure-lsp expects as :range {:row :col :end-row :end-col}. :contentReference[oaicite:3]{index=3}
            (let [{:keys [row col end-row end-col]} (meta name)]
              (reg-diagnostic!
               {:uri     uri
                :level   (:level params)
                :code    "promethean/cognitive-complexity"
                :source  "promethean/codestyle"
                :message (format "Cognitive complexity %d > %d for %s"
                                 score max-allowed name)
                :range   {:row row :col col :end-row end-row :end-col end-col}}))))))))

```

### 3) Restart clojure-lsp in Emacs

* `lsp-mode`: restart workspace (or kill/restart the server)
* `eglot`: reconnect / restart the project

After that, as soon as your agents generate a gnarly `defn`, they’ll get a diagnostic warning/error from the language server.

---

## Per-function overrides (so it’s practical)

**Raise the max for one function:**

```clojure
(defn ^{:cognitive-complexity/max 25} ok-its-a-beast [] ...)
```

**Ignore one function entirely:**

```clojure
(defn ^{:cognitive-complexity/ignore true} generated-or-legacy [] ...)
```

---

## Notes on “Sonar accuracy”

This is *Sonar-inspired*, not a perfect clone. Sonar’s definition is explicitly about linear-flow breaks + nesting penalties ([simona.ie3.e-technik.tu-dortmund.de][1]), but different languages have little quirks (e.g. `cond` vs `else-if`, `and/or` macros, etc). The implementation above is tuned to catch the stuff that usually makes Clojure functions hard to read (deep nesting, lots of branching), while keeping false positives manageable.

If you want, I can tweak the scoring rules to match your style (e.g. treat `cond->` as lower cost, count `some->` branches, count `and/or`, treat `if` in else as “else-if” style, etc.).

[1]: https://simona.ie3.e-technik.tu-dortmund.de/sonar/coding_rules?open=rust%3AS3776&rule_key=rust%3AS3776&utm_source=chatgpt.com "Cognitive Complexity of functions should not be too high"
[2]: https://marketplace.visualstudio.com/items?itemName=SonarSource.sonarlint-vscode&utm_source=chatgpt.com "SonarQube for IDE: Visual Studio Code (formerly SonarLint)"
[3]: https://clojure-lsp.io/settings/ "Settings - Clojure LSP"
