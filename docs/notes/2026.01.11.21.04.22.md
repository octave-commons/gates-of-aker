Alright—here’s a **minimal, working “Myth Engine in a Box”** scaffold:

* **Clojure backend** (http-kit + WebSocket + JSON)
* **Web view** (Vite + React + TS)
* A tiny sim with:

  * agents moving on a grid
  * facet packets (`:cold`, `:trees`, …)
  * sparse “frontier activation” + edge spread (`cold→fire→patron`)
  * a single event archetype (`:winter-pyre`)
  * mention traces streamed over WebSocket
  * simple player levers (`iconography`, `shrine`, `mouthpiece`)

Everything below is **full file contents** (no diffs).

---

# 1) Folder layout

```
fantasia/
  backend/
    deps.edn
    src/fantasia/server.clj
    src/fantasia/sim/core.clj
    src/fantasia/sim/facets.clj
    src/fantasia/sim/myth.clj
  web/
    package.json
    vite.config.ts
    tsconfig.json
    index.html
    src/main.tsx
    src/ws.ts
    src/App.tsx
```

---

# 2) Backend (Clojure)

## `backend/deps.edn`

```clojure
{:paths ["src"]
 :deps
 {org.clojure/clojure {:mvn/version "1.11.3"}
  http-kit/http-kit {:mvn/version "2.8.0"}
  metosin/reitit-ring {:mvn/version "0.7.2"}
  cheshire/cheshire {:mvn/version "5.13.0"}}

 :aliases
 {:server
  {:main-opts ["-m" "fantasia.server"]}}}
```

## `backend/src/fantasia/sim/facets.clj`

```clojure
(ns fantasia.sim.facets)

(defn clamp01 ^double [^double x]
  (cond
    (neg? x) 0.0
    (> x 1.0) 1.0
    :else x))

(defn bump-facet
  "Add delta to facet activation in an agent frontier."
  [frontier facet delta]
  (let [{:keys [a strength valence]} (get frontier facet {:a 0.0 :strength 0.2 :valence 0.0})
        a' (clamp01 (+ (double a) (double delta)))]
    (assoc frontier facet {:a a' :strength strength :valence valence})))

(defn decay-frontier
  "Decay activations each tick. Keep sparse frontier by dropping tiny activations."
  [frontier {:keys [decay drop-threshold] :or {decay 0.92 drop-threshold 0.02}}]
  (->> frontier
       (map (fn [[k {:keys [a strength valence]}]]
              (let [a' (* (double a) (double decay))]
                [k {:a a' :strength strength :valence valence}])))
       (remove (fn [[_ {:keys [a]}]] (< (double a) (double drop-threshold))))
       (into {})))

(defn seed
  "Seed facets directly from a packet bundle."
  [frontier facets {:keys [seed-strength] :or {seed-strength 0.28}}]
  (reduce (fn [fr f] (bump-facet fr f seed-strength))
          frontier
          facets))

(defn spread-step
  "One hop of spreading along weighted edges.
  edges is a map {[from to] w} with w in [0..1]."
  [frontier edges {:keys [spread-gain max-hops] :or {spread-gain 0.55 max-hops 2}}]
  (loop [hop 0
         fr frontier
         deltas []]
    (if (>= hop max-hops)
      {:frontier fr :deltas deltas}
      (let [active (sort-by (fn [[_ {:keys [a]}]] (- (double a))) fr)
            ;; small frontier = safe; take top 24 active facets
            active (take 24 active)
            step (reduce
                   (fn [{:keys [fr deltas]} [from {:keys [a]}]]
                     (reduce
                       (fn [{:keys [fr deltas]} [[f t] w]]
                         (if (= f from)
                           (let [delta (* (double a) (double w) (double spread-gain))
                                 fr' (bump-facet fr t delta)]
                             {:fr fr'
                              :deltas (conj deltas {:from f :to t :w w :delta delta})})
                           {:fr fr :deltas deltas}))
                       {:fr fr :deltas deltas}
                       edges))
                   {:fr fr :deltas deltas}
                   active)]
        (recur (inc hop) (:fr step) (:deltas step))))))

(defn event-recall
  "Compute recall activation for an event from a facet signature.
  signature: {facet weight}."
  [frontier signature {:keys [threshold] :or {threshold 0.70}}]
  (let [score (reduce
                (fn [acc [facet w]]
                  (let [a (double (get-in frontier [facet :a] 0.0))]
                    (+ acc (* a (double w)))))
                0.0
                signature)]
    {:score score
     :recalled? (>= score (double threshold))}))
```

## `backend/src/fantasia/sim/myth.clj`

```clojure
(ns fantasia.sim.myth)

(defn decay-ledger
  "Decay buzz/tradition each tick. Keeps belief from becoming permanently stuck."
  [ledger]
  (let [buzz-decay 0.90
        trad-decay 0.995]
    (into {}
          (map (fn [[k v]]
                 [k (-> v
                        (update :buzz (fnil #(* (double %) buzz-decay) 0.0))
                        (update :tradition (fnil #(* (double %) trad-decay) 0.0)))])
               ledger))))

(defn add-mention
  "Update ledger for (event-type, claim)."
  [ledger {:keys [event-type claim weight]}]
  (let [k [event-type claim]
        w (double weight)]
    (-> ledger
        (update-in [k :buzz] (fnil + 0.0) w)
        ;; tradition grows slower than buzz; log-ish makes sustained talk matter more
        (update-in [k :tradition] (fnil + 0.0) (* 0.12 (Math/log (+ 1.0 w))))
        (update-in [k :mentions] (fnil inc 0)))))

(defn attribution
  "Compute attribution probabilities per event-type from ledger."
  [ledger event-type]
  (let [rows (for [[[et claim] {:keys [tradition]}] ledger
                   :when (= et event-type)]
               [claim (double (or tradition 0.0))])
        total (reduce + 0.0 (map second rows))
        eps 1.0e-9
        total (max total eps)]
    (into {}
          (map (fn [[c t]] [c (/ t total)]) rows))))
```

## `backend/src/fantasia/sim/core.clj`

```clojure
(ns fantasia.sim.core
  (:require [fantasia.sim.facets :as f]
            [fantasia.sim.myth :as myth]))

(def default-signatures
  {:winter-pyre
   {:winter 0.8
    :cold 0.6
    :trees 0.7
    :fire 1.0
    :smoke 0.3
    :enemy-rout 0.7
    :awe 0.6
    :judgment 0.6
    :patron/fire 0.7}})

(defn rng [seed]
  (java.util.Random. (long seed)))

(defn rand-int* [^java.util.Random r n]
  (.nextInt r (int n)))

(defn rand-double* [^java.util.Random r]
  (.nextDouble r))

(defn ->agent [id x y role]
  {:id id
   :pos [x y]
   :role role
   :needs {:warmth 0.6 :food 0.7 :sleep 0.7}
   ;; sparse frontier: facet -> {:a :strength :valence}
   :frontier {}
   ;; store last recall score for delta/mention detection
   :recall {:winter-pyre 0.0}})

(defn initial-world [seed]
  (let [r (rng seed)]
    {:seed seed
     :tick 0
     :size [20 20]
     ;; simple “biome” tags: trees patch in the north-east
     :trees (set (for [x (range 10 18)
                       y (range 2 10)]
                   [x y]))
     ;; a single shrine marker (optional), nil until placed
     :shrine nil
     :cold-snap 0.85
     ;; player levers
     :levers {:iconography {:fire->patron 0.80}  ;; edge weight multiplier
              :mouthpiece-agent-id nil}
     ;; institutions: one temple broadcast
     :institutions
     {:temple {:id :temple
               :name "Temple of Embers"
               :entropy 0.2
               :broadcast-every 6
               :canonical {:facets [:fire :judgment :winter]
                           :claim :claim/winter-judgment-flame}}}
     :agents
     (vec (for [i (range 12)]
            (->agent i (rand-int* r 20) (rand-int* r 20)
                    (cond
                      (= i 0) :priest
                      (= i 1) :knight
                      :else :peasant))))
     ;; co-occur / symbolic edges (directed)
     :edges
     {[ :cold :fire] 0.60
      [ :trees :fire] 0.45
      [ :fire :patron/fire] 0.80
      [ :patron/fire :judgment] 0.35
      [ :judgment :winter-pyre] 0.15}
     ;; myth ledger
     :ledger {}
     ;; traces ringbuffer
     :traces []
     :trace-max 200}))

(defn in-bounds? [[w h] [x y]]
  (and (<= 0 x) (< x w) (<= 0 y) (< y h)))

(defn manhattan [[ax ay] [bx by]]
  (+ (Math/abs (long (- ax bx))) (Math/abs (long (- ay by)))))

(defn neighbors [pos]
  (let [[x y] pos]
    [[(inc x) y] [(dec x) y] [x (inc y)] [x (dec y)]]))

(defn move-agent [world agent]
  (let [size (:size world)
        options (->> (neighbors (:pos agent))
                     (filter #(in-bounds? size %))
                     vec)]
    (if (seq options)
      (assoc agent :pos (nth options (rand-int* (rng (+ (:seed world) (:tick world) (:id agent))) (count options))))
      agent)))

(defn update-needs [world agent]
  (let [cold (:cold-snap world)
        warmth (get-in agent [:needs :warmth] 0.6)
        ;; colder world drains warmth
        warmth' (f/clamp01 (- warmth (* 0.03 cold)))
        food' (f/clamp01 (- (get-in agent [:needs :food] 0.7) 0.01))
        sleep' (f/clamp01 (- (get-in agent [:needs :sleep] 0.7) 0.008))]
    (assoc agent :needs {:warmth warmth' :food food' :sleep sleep'})))

(defn at-trees? [world pos]
  (contains? (:trees world) pos))

(defn near-shrine? [world pos]
  (when-let [s (:shrine world)]
    (<= (manhattan pos s) 3)))

(defn choose-packet
  "Speaker decides what facets to emit this tick.
  We keep it tiny: mostly cold + (trees if near trees), plus occasional prayer framing by priests."
  [world agent]
  (let [warmth (get-in agent [:needs :warmth] 0.5)
        base (cond-> [:cold]
               (at-trees? world (:pos agent)) (conj :trees)
               (< warmth 0.25) (conj :fear))
        base (if (= (:role agent) :priest)
               (conj base :judgment)
               base)]
    {:intent (cond
               (< warmth 0.25) :warn
               (= (:role agent) :priest) :convert
               :else :chatter)
     :facets base
     :tone {:awe (if (= (:role agent) :priest) 0.3 0.1)
            :urgency (if (< warmth 0.25) 0.6 0.2)}}))

(defn interactions
  "Return speaker/listener pairs for agents within distance 1."
  [agents]
  (for [a agents
        b agents
        :when (and (not= (:id a) (:id b))
                   (<= (manhattan (:pos a) (:pos b)) 1))]
    [a b]))

(defn apply-packet-to-listener
  "Seed + spread in listener frontier; compute event recall delta; maybe produce a mention trace."
  [world listener speaker packet]
  (let [edges (let [m (get-in world [:levers :iconography :fire->patron] 0.8)
                    base (:edges world)]
                ;; scale the fire->patron edge by iconography lever
                (assoc base [:fire :patron/fire] (double m)))
        ;; decay first
        fr0 (f/decay-frontier (:frontier listener) {:decay 0.93})
        ;; shrine influence: if near shrine, pre-seed fire lightly (environment trigger)
        fr0 (if (near-shrine? world (:pos listener))
              (f/bump-facet fr0 :fire 0.08)
              fr0)
        ;; seed packet facets
        fr1 (f/seed fr0 (:facets packet) {:seed-strength 0.30})
        ;; spread along edges
        spread (f/spread-step fr1 edges {:spread-gain 0.50 :max-hops 2})
        fr2 (:frontier spread)
        deltas (:deltas spread)
        ;; event recall
        sig (get default-signatures :winter-pyre)
        recall (f/event-recall fr2 sig {:threshold 0.75})
        old (double (get-in listener [:recall :winter-pyre] 0.0))
        new (double (:score recall))
        drec (- new old)
        ;; mention threshold
        mention? (> drec 0.18)
        ;; compute weight (tiny, but enough)
        weight (* drec
                  (if (= (:role speaker) :priest) 1.2 1.0)
                  (if (= (:role listener) :knight) 1.1 1.0))
        claim (if (>= (get-in world [:levers :iconography :fire->patron] 0.8) 0.55)
                :claim/winter-judgment-flame
                :rebuttal/natural-chance)
        trace (when mention?
                {:trace/id (str "t-" (:tick world) "-" (:id listener) "-" (:id speaker))
                 :tick (:tick world)
                 :listener (:id listener)
                 :speaker (:id speaker)
                 :packet packet
                 :seeded (mapv (fn [f] {:facet f :delta 0.30}) (:facets packet))
                 :spread (take 18 deltas)
                 :event-recall {:event-type :winter-pyre :delta drec :new new}
                 :claim-activation [{:claim claim :delta (* 0.6 drec)}]
                 :mention {:event-type :winter-pyre :claim claim :weight weight}})]
    {:listener (-> listener
                  (assoc :frontier fr2)
                  (assoc-in [:recall :winter-pyre] new))
     :mention (when mention?
                {:event-type :winter-pyre
                 :claim claim
                 :weight weight})
     :trace trace}))

(defn institution-broadcasts [world]
  (let [t (:tick world)
        insts (vals (:institutions world))]
    (for [inst insts
          :let [every (:broadcast-every inst)]
          :when (and every (pos? every) (zero? (mod t every)))]
      {:institution (:id inst)
       :packet {:intent :convert
                :facets (get-in inst [:canonical :facets] [])
                :tone {:awe 0.5 :urgency 0.2}}
       :claim (get-in inst [:canonical :claim])})))

(defn apply-institution-broadcast
  "Broadcast to all agents (low entropy, so we explicitly seed the canonical facets)."
  [world agents {:keys [institution packet]}]
  (reduce
    (fn [acc a]
      (let [res (apply-packet-to-listener world a {:id (keyword (name institution))} packet)]
        (-> acc
            (update :agents conj (:listener res))
            (update :mentions (fnil into []) (when-let [m (:mention res)] [m]))
            (update :traces (fnil into []) (when-let [tr (:trace res)] [tr])))))
    {:agents [] :mentions [] :traces []}
    agents))

(defn tick-once
  "Advance world by one tick. Returns {:world w' :out {...}}.
  out includes traces + mentions + snapshot."
  [world]
  (let [t (inc (:tick world))
        world (assoc world :tick t)
        ;; move + needs update
        agents1 (->> (:agents world)
                     (map (fn [a] (->> a (move-agent world) (update-needs world))))
                     vec)
        ;; pairwise interactions
        pairs (interactions agents1)
        ;; apply packets
        step (reduce
               (fn [{:keys [agents mentions traces]} [speaker listener]]
                 (let [packet (choose-packet world speaker)
                       res (apply-packet-to-listener world listener speaker packet)
                       agents' (assoc agents (:id listener) (:listener res))]
                   {:agents agents'
                    :mentions (cond-> mentions (:mention res) (conj (:mention res)))
                    :traces (cond-> traces (:trace res) (conj (:trace res)))}))
               {:agents (vec agents1) :mentions [] :traces []}
               pairs)
        agents2 (:agents step)

        ;; institution broadcasts
        bcasts (institution-broadcasts world)
        inst-step (reduce
                    (fn [{:keys [agents mentions traces]} b]
                      (let [res (apply-institution-broadcast world agents b)]
                        {:agents (:agents res)
                         :mentions (into mentions (:mentions res))
                         :traces (into traces (:traces res))}))
                    {:agents agents2 :mentions (:mentions step) :traces (:traces step)}
                    bcasts)

        agents3 (:agents inst-step)

        ;; update ledger
        ledger1 (myth/decay-ledger (:ledger world))
        ledger2 (reduce myth/add-mention ledger1 (:mentions inst-step))
        attr (myth/attribution ledger2 :winter-pyre)

        ;; append traces (ringbuffer)
        traces' (->> (concat (:traces world) (:traces inst-step))
                     (take-last (:trace-max world))
                     vec)

        world' (-> world
                   (assoc :agents agents3)
                   (assoc :ledger ledger2)
                   (assoc :traces traces'))]

    {:world world'
     :out {:tick t
           :mentions (:mentions inst-step)
           :traces (:traces inst-step)
           :attribution {:winter-pyre attr}
           :snapshot {:tick t
                      :shrine (:shrine world')
                      :levers (:levers world')
                      :agents (mapv (fn [a]
                                      {:id (:id a)
                                       :pos (:pos a)
                                       :role (:role a)
                                       :needs (:needs a)
                                       :top-facets (->> (:frontier a)
                                                        (sort-by (fn [[_ {:keys [a]}]] (- (double a))))
                                                        (take 6)
                                                        (mapv (fn [[k v]] {:facet k :a (:a v)})))
                                       :recall (:recall a)})
                                    (:agents world'))
                      :ledger (into {}
                                    (map (fn [[[et claim] v]]
                                           [(str (name et) "/" (name claim))
                                            {:buzz (:buzz v) :tradition (:tradition v) :mentions (:mentions v)}])
                                         ledger2))}}}}))

(defonce *state (atom (initial-world 1)))

(defn get-state [] @*state)

(defn reset! [{:keys [seed] :or {seed 1}}]
  (reset! *state (initial-world seed)))

(defn set-levers! [levers]
  (swap! *state update :levers merge levers))

(defn place-shrine! [pos]
  (swap! *state assoc :shrine pos))

(defn appoint-mouthpiece! [agent-id]
  (swap! *state assoc-in [:levers :mouthpiece-agent-id] agent-id))

(defn tick! [n]
  (loop [i 0
         outs []]
    (if (>= i n)
      outs
      (let [{:keys [world out]} (tick-once (get-state))]
        (reset! *state world)
        (recur (inc i) (conj outs out))))))
```

## `backend/src/fantasia/server.clj`

```clojure
(ns fantasia.server
  (:gen-class)
  (:require
    [cheshire.core :as json]
    [clojure.string :as str]
    [org.httpkit.server :as http]
    [reitit.ring :as ring]
    [fantasia.sim.core :as sim]))

(defn json-resp
  ([m] (json-resp 200 m))
  ([status m]
   {:status status
    :headers {"content-type" "application/json"
              "access-control-allow-origin" "*"
              "access-control-allow-headers" "content-type"
              "access-control-allow-methods" "GET,POST,OPTIONS"}
    :body (json/generate-string m)}))

(defn read-json-body [req]
  (try
    (when-let [b (:body req)]
      (let [s (slurp b)]
        (when-not (str/blank? s)
          (json/parse-string s true))))
    (catch Exception _
      nil)))

(defonce *clients (atom #{}))
(defonce *runner (atom {:running? false :future nil :ms 250}))

(defn ws-send! [ch msg]
  (http/send! ch (json/generate-string msg)))

(defn broadcast! [msg]
  (doseq [ch @*clients]
    (ws-send! ch msg)))

(defn handle-ws [req]
  (http/with-channel req ch
    (swap! *clients conj ch)
    (ws-send! ch {:op "hello"
                  :state (select-keys (sim/get-state) [:tick :shrine :levers])})
    (http/on-close ch (fn [_] (swap! *clients disj ch)))
    (http/on-receive
      ch
      (fn [raw]
        (let [msg (try (json/parse-string raw true) (catch Exception _ nil))
              op (:op msg)]
          (case op
            "tick"
            (let [n (int (or (:n msg) 1))
                  outs (sim/tick! n)]
              ;; broadcast only last snapshot + any traces
              (doseq [o outs]
                (broadcast! {:op "tick" :data (select-keys o [:tick :snapshot :attribution])})
                (doseq [tr (:traces o)]
                  (broadcast! {:op "trace" :data tr}))))
            "reset"
            (do (sim/reset! {:seed (long (or (:seed msg) 1))})
                (broadcast! {:op "reset" :state (sim/get-state)}))
            "set_levers"
            (do (sim/set-levers! (:levers msg))
                (broadcast! {:op "levers" :levers (:levers (sim/get-state))}))
            "place_shrine"
            (do (sim/place-shrine! (:pos msg))
                (broadcast! {:op "shrine" :shrine (:shrine (sim/get-state))}))
            "appoint_mouthpiece"
            (do (sim/appoint-mouthpiece! (:agent_id msg))
                (broadcast! {:op "mouthpiece" :mouthpiece (get-in (sim/get-state) [:levers :mouthpiece-agent-id])}))
            ;; default
            (ws-send! ch {:op "error" :message "unknown op"})))))))

(defn start-runner! []
  (let [{:keys [running?]} @*runner]
    (when-not running?
      (let [fut (future
                  (swap! *runner assoc :running? true)
                  (try
                    (while (:running? @*runner)
                      (let [outs (sim/tick! 1)
                            o (last outs)]
                        (broadcast! {:op "tick" :data (select-keys o [:tick :snapshot :attribution])})
                        (doseq [tr (:traces o)]
                          (broadcast! {:op "trace" :data tr})))
                      (Thread/sleep (long (:ms @*runner))))
                    (finally
                      (swap! *runner assoc :running? false :future nil))))]
        (swap! *runner assoc :future fut)))))

(defn stop-runner! []
  (swap! *runner assoc :running? false)
  true)

(def app
  (ring/ring-handler
    (ring/router
      [["/healthz"
        {:get (fn [_] (json-resp {:ok true}))
         :options (fn [_] (json-resp 200 {:ok true}))}]

       ["/ws"
        {:get handle-ws}]

       ["/sim/state"
        {:get (fn [_] (json-resp 200 (sim/get-state)))
         :options (fn [_] (json-resp 200 {:ok true}))}]

       ["/sim/reset"
        {:post (fn [req]
                 (let [b (read-json-body req)
                       seed (long (or (:seed b) 1))]
                   (sim/reset! {:seed seed})
                   (json-resp 200 {:ok true :seed seed})))
         :options (fn [_] (json-resp 200 {:ok true}))}]

       ["/sim/tick"
        {:post (fn [req]
                 (let [b (read-json-body req)
                       n (int (or (:n b) 1))
                       outs (sim/tick! n)]
                   (json-resp 200 {:ok true :last (last outs)})))
         :options (fn [_] (json-resp 200 {:ok true}))}]

       ["/sim/run"
        {:post (fn [_] (start-runner!) (json-resp 200 {:ok true :running true}))
         :options (fn [_] (json-resp 200 {:ok true}))}]

       ["/sim/pause"
        {:post (fn [_] (stop-runner!) (json-resp 200 {:ok true :running false}))
         :options (fn [_] (json-resp 200 {:ok true}))}]])))

(defn -main [& _]
  (let [port 3000]
    (println (str "Fantasia backend listening on http://localhost:" port))
    (http/run-server app {:port port})
    ;; keep main thread alive
    @(promise)))
```

> Note: there’s a `fantasia.sim.groups.clj` placeholder in the plan—right now institution logic is embedded in `sim.core` for speed. We can split it cleanly once you start iterating.

---

# 3) Web view (React + TS)

## `web/package.json`

```json
{
  "name": "fantasia-web",
  "private": true,
  "version": "0.0.1",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5.7.0",
    "vite": "^6.0.0"
  }
}
```

## `web/vite.config.ts`

```ts
import { defineConfig } from "vite";

export default defineConfig({
  server: {
    port: 5173,
  },
});
```

## `web/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "strict": true,
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": ["src"]
}
```

## `web/index.html`

```html
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fantasia — Myth Debugger</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

## `web/src/main.tsx`

```tsx
import React from "react";
import { createRoot } from "react-dom/client";
import { App } from "./App";

createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## `web/src/ws.ts`

```ts
export type WSMessage =
  | { op: "hello"; state: any }
  | { op: "tick"; data: any }
  | { op: "trace"; data: any }
  | { op: "reset"; state: any }
  | { op: "levers"; levers: any }
  | { op: "shrine"; shrine: any }
  | { op: "mouthpiece"; mouthpiece: any }
  | { op: "error"; message: string }
  | { op: string; [k: string]: any };

export class WSClient {
  private ws: WebSocket | null = null;

  constructor(
    private url: string,
    private onMessage: (m: WSMessage) => void,
    private onStatus: (s: "open" | "closed" | "error") => void
  ) {}

  connect() {
    this.ws = new WebSocket(this.url);
    this.ws.onopen = () => this.onStatus("open");
    this.ws.onclose = () => this.onStatus("closed");
    this.ws.onerror = () => this.onStatus("error");
    this.ws.onmessage = (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        this.onMessage(msg);
      } catch {
        // ignore
      }
    };
  }

  send(msg: any) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    this.ws.send(JSON.stringify(msg));
  }

  close() {
    this.ws?.close();
  }
}
```

## `web/src/App.tsx`

```tsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import { WSClient, WSMessage } from "./ws";

type Trace = any;

function fmt(n: any) {
  if (typeof n === "number") return n.toFixed(3);
  return String(n);
}

export function App() {
  const [status, setStatus] = useState<"open" | "closed" | "error">("closed");
  const [tick, setTick] = useState<number>(0);
  const [snapshot, setSnapshot] = useState<any>(null);
  const [attribution, setAttribution] = useState<any>(null);
  const [traces, setTraces] = useState<Trace[]>([]);
  const [fireToPatron, setFireToPatron] = useState<number>(0.8);

  const client = useMemo(() => {
    const url = `ws://localhost:3000/ws`;
    return new WSClient(
      url,
      (m: WSMessage) => {
        if (m.op === "hello") {
          // minimal state
        }
        if (m.op === "tick") {
          setTick(m.data?.tick ?? tick);
          setSnapshot(m.data?.snapshot ?? null);
          setAttribution(m.data?.attribution ?? null);
        }
        if (m.op === "trace") {
          setTraces((prev) => {
            const next = [...prev, m.data];
            return next.slice(Math.max(0, next.length - 200));
          });
        }
        if (m.op === "reset") {
          setTraces([]);
        }
      },
      (s) => setStatus(s)
    );
  }, []);

  useEffect(() => {
    client.connect();
    return () => client.close();
  }, [client]);

  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  // render simple grid + agents + shrine
  useEffect(() => {
    const c = canvasRef.current;
    if (!c || !snapshot) return;
    const ctx = c.getContext("2d");
    if (!ctx) return;

    const W = 480;
    const H = 480;
    c.width = W;
    c.height = H;

    const size = 20;
    const cell = Math.floor(W / size);

    ctx.clearRect(0, 0, W, H);

    // grid
    ctx.globalAlpha = 0.25;
    for (let x = 0; x < size; x++) {
      for (let y = 0; y < size; y++) {
        ctx.strokeRect(x * cell, y * cell, cell, cell);
      }
    }
    ctx.globalAlpha = 1;

    // shrine
    if (snapshot.shrine) {
      const [sx, sy] = snapshot.shrine;
      ctx.fillRect(sx * cell + cell * 0.2, sy * cell + cell * 0.2, cell * 0.6, cell * 0.6);
    }

    // agents
    for (const a of snapshot.agents ?? []) {
      const [x, y] = a.pos;
      ctx.beginPath();
      ctx.arc(x * cell + cell / 2, y * cell + cell / 2, cell * 0.28, 0, Math.PI * 2);
      ctx.fill();
    }
  }, [snapshot]);

  function sendTick(n: number) {
    client.send({ op: "tick", n });
  }

  function reset(seed: number) {
    client.send({ op: "reset", seed });
  }

  function placeShrineRandom() {
    const x = Math.floor(Math.random() * 20);
    const y = Math.floor(Math.random() * 20);
    client.send({ op: "place_shrine", pos: [x, y] });
  }

  function applyLevers() {
    client.send({ op: "set_levers", levers: { iconography: { "fire->patron": fireToPatron } } });
  }

  return (
    <div style={{ display: "grid", gridTemplateColumns: "520px 1fr", gap: 16, padding: 16 }}>
      <div>
        <div style={{ display: "flex", gap: 8, alignItems: "center", marginBottom: 8 }}>
          <strong>Fantasia — Myth Debugger</strong>
          <span style={{ opacity: 0.7 }}>WS: {status}</span>
        </div>

        <div style={{ display: "flex", gap: 8, marginBottom: 8, flexWrap: "wrap" }}>
          <button onClick={() => sendTick(1)}>Tick</button>
          <button onClick={() => sendTick(10)}>Tick×10</button>
          <button onClick={() => reset(1)}>Reset</button>
          <button onClick={placeShrineRandom}>Place shrine</button>
        </div>

        <div style={{ marginBottom: 12 }}>
          <div style={{ marginBottom: 4 }}>
            <strong>Tick:</strong> {tick}
          </div>

          <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
            <label style={{ display: "flex", gap: 8, alignItems: "center" }}>
              fire→patron
              <input
                type="range"
                min={0}
                max={1}
                step={0.01}
                value={fireToPatron}
                onChange={(e) => setFireToPatron(Number(e.target.value))}
              />
              <span>{fireToPatron.toFixed(2)}</span>
            </label>
            <button onClick={applyLevers}>Apply</button>
          </div>
        </div>

        <canvas ref={canvasRef} style={{ border: "1px solid #999", borderRadius: 8 }} />

        <div style={{ marginTop: 12 }}>
          <strong>Attribution (winter-pyre)</strong>
          <pre style={{ whiteSpace: "pre-wrap" }}>{JSON.stringify(attribution, null, 2)}</pre>
        </div>

        <div style={{ marginTop: 12 }}>
          <strong>Ledger</strong>
          <pre style={{ whiteSpace: "pre-wrap" }}>{JSON.stringify(snapshot?.ledger ?? null, null, 2)}</pre>
        </div>
      </div>

      <div>
        <div style={{ marginBottom: 8 }}>
          <strong>Traces</strong> <span style={{ opacity: 0.7 }}>({traces.length})</span>
        </div>

        <div style={{ display: "grid", gap: 10 }}>
          {traces
            .slice()
            .reverse()
            .map((tr: any) => (
              <div key={tr["trace/id"]} style={{ border: "1px solid #aaa", borderRadius: 10, padding: 10 }}>
                <div style={{ display: "flex", gap: 10, flexWrap: "wrap" }}>
                  <div>
                    <strong>{tr["trace/id"]}</strong>
                  </div>
                  <div style={{ opacity: 0.7 }}>tick {tr.tick}</div>
                  <div style={{ opacity: 0.7 }}>speaker {tr.speaker} → listener {tr.listener}</div>
                </div>

                <div style={{ marginTop: 8 }}>
                  <div>
                    <strong>packet</strong>{" "}
                    <span style={{ opacity: 0.8 }}>{tr.packet.intent}</span>{" "}
                    <code>{JSON.stringify(tr.packet.facets)}</code>
                  </div>
                </div>

                <div style={{ marginTop: 8 }}>
                  <strong>spread</strong>
                  <div style={{ display: "grid", gap: 4, marginTop: 4 }}>
                    {(tr.spread ?? []).slice(0, 10).map((s: any, i: number) => (
                      <div key={i} style={{ fontFamily: "monospace", fontSize: 12 }}>
                        {String(s.from)} → {String(s.to)} w={fmt(s.w)} Δ={fmt(s.delta)}
                      </div>
                    ))}
                  </div>
                </div>

                <div style={{ marginTop: 8 }}>
                  <strong>event</strong>{" "}
                  <span style={{ fontFamily: "monospace" }}>
                    {tr["event-recall"]?.["event-type"]} Δ={fmt(tr["event-recall"]?.delta)} new={fmt(tr["event-recall"]?.new)}
                  </span>
                </div>

                <div style={{ marginTop: 8 }}>
                  <strong>mention</strong>{" "}
                  <span style={{ fontFamily: "monospace" }}>
                    {tr.mention?.["event-type"]}/{tr.mention?.claim} w={fmt(tr.mention?.weight)}
                  </span>
                </div>
              </div>
            ))}
        </div>
      </div>
    </div>
  );
}
```

---

# 4) Running it

## Backend

```bash
cd fantasia/backend
clojure -M:server
```

Backend listens on:

* `http://localhost:3000/healthz`
* `ws://localhost:3000/ws`

## Web

```bash
cd fantasia/web
npm i
npm run dev
```

Open:

* `http://localhost:5173`

Then hit **Tick** / **Tick×10** and watch traces appear.

---

# 5) What to look for in the trace UI

You should see chains like:

* packet facets: `[:cold :trees]`
* spread: `cold → fire`, `fire → patron/fire`, …
* event recall: `winter-pyre` score jump
* mention recorded (with weight)
* attribution drift changes when you slide `fire→patron`

That’s the “this idea is alive” moment.

---

# 6) Next tight iteration (after you confirm it runs)

1. Add a **rival deity path** (e.g. `:storm → :deity/storm`) and competing iconography lever.
2. Make the **temple broadcast** depend on **mouthpiece-agent-id** (so appointing matters).
3. Replace the hardcoded `:winter-pyre` recall with:

   * event archetype registry (the `defeventtype` DSL you wanted)
   * multiple event types and contested claims

Say the word and I’ll extend this scaffold in that direction without ballooning complexity.
