# MVP v0 (playable target)

## Related Documentation
- [[README.md]] - Project overview
- [[AGENTS.md]] - Coding standards
- [[docs/notes/planning/2026-01-15-roadmap.md]] - Sprint and milestone roadmap
- [[spec/2026-01-15-core-loop.md]] - Day/night cycle mechanics
- [[spec/2026-01-15-gates-of-aker-roadmap.md]] - Roadmap summary
- [[docs/notes/design/2026-01-15-world-schema.md]] - World schema

**"A simple RimWorld clone + powers + champion control"** means:

*   **Hex map** with **walls** that block movement.

*   A tiny colony loop: **gather wood → build walls → eat/sleep**.

*   **Champion** is directly controlled during **Day**.

*   When champion **sleeps**, it becomes **Night**, and **deities/cards** can act.

*   **6 neighbor factions** exist (one per hex direction) and each has a **deck**.


* * *

Epics (dependency order) #epic
------------------------------

1.  **HexMap** → axial coords, render, selection, map bounds

2.  **WallsAndPathing** → passability + A\* (or BFS first) + build ghosts

3.  **ColonyCore** → jobs, items, stockpile, needs-driven behavior

4.  **ChampionLoop** → day control + sleep/night gate

5.  **Factions6** → 6 neighbors + settlement markers + simple behavior

6.  **DecksAndSigns** → 6 decks + card play + signs + collision resolution

7.  **MythIntegration** → pipe _real events_ into myth (instead of synthetic RNG)


* * *

Sprint 1 (do next): HexMap backbone + renderer #sprint
------------------------------------------------------

### Goal

Swap the world from **20×20 square** to **hex axial**, and update the UI canvas to draw/select hexes. This unlocks _everything_ else (walls, 6 neighbors, rings, routes).

### Definition of Done

*   World stores positions as `[q r]` (axial hex coords).

*   Agents move on hex neighbors (even dumb deterministic stepping).

*   UI renders hex grid and agents; clicking selects a hex + agent on it.

*   `place_shrine` works on hex coords and renders correctly.


* * *

Key implementation decisions (lock these early)
-----------------------------------------------

### 1) Coordinate system

Use **axial coordinates** `(q, r)`.

Neighbor directions (pointy-top axial):

*   `[[+1 0] [+1 -1] [0 -1] [-1 0] [-1 +1] [0 +1]]`

### 2) Layout + pixel math

Pick **pointy-top** hexes (works great for "rings" and 6-neighbor factions).

Let `S` = hex size (radius in pixels).

**Axial → pixel**

*   $x = S \cdot \sqrt{3} \cdot (q + r/2)$

*   $y = S \cdot3/2 \cdot r$

**Pixel → axial (approx)**

*   $q \approx \frac{\sqrt{3}}{3}\frac{x}{S} - \frac{1}{3}\frac{y}{S}$

*   $r \approx \frac{2}{3}\frac{y}{S}$
    Then do **cube-rounding** (standard) and convert back to axial.

### 3) Map bounds (start simple)

Use a **radius map** (hex disk) for MVP:

*   radius `R` → total tiles $1 + 3R(R+1)$

This makes "6 neighbors around you" trivial later (place them on ring).

* * *

Repo changes for Sprint 1 (concrete file/module plan)
-----------------------------------------------------

### Backend modules

Add:

*   `backend/src/fantasia/sim/hex.clj`

    *   `dirs`, `add`, `neighbors`, `axial->cube`, `cube-round`, `pixel->axial` (backend may not need pixel math yet), `distance`, `in-radius?`

Refactor:

*   `backend/src/fantasia/sim/core.clj`

    *   Replace `:size [20 20]` with:

        ```clojure
        :map {:kind :hex
              :layout :pointy
              :bounds {:shape :radius :r 18}}
        ```
    *   Replace agent `:pos [x y]` → `[q r]`
    *   Replace `:trees` as a separate set with **tile resources** (even if minimal):

        ```clojure
        :tiles { [q r] {:terrain :ground :resource :tree}
                [q r] {:terrain :ground :structure :wall} }
        ```

        (Start sparse: only store non-default tiles.)

    *   Update:

        *   `in-bounds?` → `hex/in-radius?`

        *   `neighbors` → `hex/neighbors`

        *   `manhattan` → `hex/distance`

        *   `at-trees?` → `tile has :resource :tree`

        *   `near-shrine?` uses hex distance

    *   Keep everything else (facets/myth/events) intact.

### Snapshot contract changes

Extend `snapshot` to include map + tiles (lean):

```c
{:tick ...
 :map {:kind :hex :layout :pointy :bounds {:shape :radius :r 18}}
 :tiles {:walls [[q r] ...]
          :trees [[q r] ...]
          :shrine [q r] | nil}
 :agents [{:id ... :pos [q r] ...} ...]
 ...}
```

Why this shape:

*   UI rendering is easy (`walls` + `trees` are just position lists).

*   Later you can switch to deltas without changing semantics.

### Server / WS messages (small but important)

In `backend/src/fantasia/server.clj`:

*   Change initial `hello` payload to include a full snapshot (so UI draws immediately):

    *   Today it sends `{:state (select-keys ... [:tick :shrine :levers])}`

    *   Make it:

        ```c
        {:op "hello"
         :state (select-keys (sim/get-state) [:tick :shrine :levers])
         :snapshot (:snapshot (last (sim/tick! 0)))}
        ```

    Better: expose a `sim/snapshot-now` function so you don't have to fake a tick.

*   Keep `tick` messages as-is; they already carry `:snapshot`.

No new ops required for Sprint1 beyond existing:

*   `place_shrine` now expects axial `[q r]` (UI will send that).

* * *

Frontend plan (Sprint 1)
------------------------

### New file

*   `web/src/hex.ts`

    *   `axialToPixel(q,r,S)`

    *   `pixelToAxial(x,y,S)` + `cubeRound`

    *   `hexPolygonPoints(cx,cy,S)` for drawing

### Update `web/src/App.tsx`

Replace square grid renderer with:

*   Determine `S` from canvas size and map bounds (radius):

    *   e.g. `S = Math.floor(canvasWidth / (radius*3 + 2))` (rough) then tweak
*   Render:

    *   all hexes in radius (or only visible ones)

    *   walls/trees/shrine markers from `snapshot.tiles`

    *   agents at hex centers

Click handling:

*   Convert mouse pixel → axial coord via `pixelToAxial`

*   Select agent if any agent `pos == selectedHex`

* * *

Sprint 2 preview (so Sprint 1 choices don't paint you into a corner) #next
--------------------------------------------------------------------------

Once hex exists:

*   **Walls** become `:structure :wall` in `:tiles`

*   Add op: `place_wall_ghost` (and later `cancel_ghost`)

*   Add minimal pathing: BFS first, A\* later

*   Add build jobs: pawn builds ghost → wall

* * *

6 neighbor factions + 6 decks (how hex makes it clean) #factions #decks
-----------------------------------------------------------------------

When you're ready (after Sprint 1–3), placing neighbors is literally:

Let `D` = settlement distance (e.g. 12). For each of 6 direction vectors `dir[i]`:

*   `settlement[i].pos = center + dir[i] * D`

Then each neighbor faction gets:

*   `:faction/id`

*   `:faction/settlement-pos`

*   `:faction/deck` (draw pile / discard / hand)

The _deck engine_ you already started designing slots right in at the Aker boundary.

* * *
