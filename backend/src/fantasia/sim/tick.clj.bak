(ns fantasia.sim.tick
   (:require [fantasia.sim.agents :as agents]
             [fantasia.sim.events.runtime :as runtime]
             [fantasia.sim.institutions :as institutions]
             [fantasia.sim.spatial :as spatial]
             [fantasia.sim.hex :as hex]
             [fantasia.sim.world :as world]
             [fantasia.sim.jobs :as jobs]
             [fantasia.sim.pathing :as pathing]
             [clojure.string :as str]))

(defn rng [seed] (java.util.Random. (long seed)))
(defn rand-int* [^java.util.Random r n] (.nextInt r (int n)))

(defn ->agent [id q r role]
   {:id id
    :pos [q r]
    :role role
    :needs {:warmth 0.6 :food 0.7 :sleep 0.7}
    :need-thresholds {:food-starve 0.0 :food-hungry 0.3 :food-satisfied 0.8
                      :sleep-exhausted 0.0 :sleep-tired 0.3 :sleep-rested 0.8}
    :inventory {:wood 0 :food 0}
    :frontier {}
    :recall {}})

(defn initial-world [opts]
  (let [{:keys [seed bounds]} opts
        actual-seed (or seed 1)
        r (rng actual-seed)
        hex-bounds (hex/normalize-bounds bounds {:shape :rect :w 128 :h 128})
        hex-map {:kind :hex
                  :layout :pointy
                  :bounds hex-bounds}]
     {    :seed actual-seed
      :tick 0
      :map hex-map
      :tiles {"10,2" {:terrain :ground :resource :tree :last-fruit-drop 0}}
      :shrine nil
     :cold-snap 0.85
     :jobs []
     :items {}
     :stockpiles {}
     :levers {:iconography {:fire->patron 0.80
                             :lightning->storm 0.75
                             :storm->deity 0.85}
                :mouthpiece-agent-id nil}
     :institutions
     {:temple {:id :temple
                :name "Temple of Embers"
                :entropy 0.2
                :broadcast-every 6
                :canonical {:facets [:fire :judgment :winter]
                            :claim-hint :claim/winter-judgment-flame}}}
     :agents (vec (for [i (range 12)]
                     (let [[q r] (hex/rand-pos r hex-map)]
                       (->agent i q r (cond
                                           (= i 0) :priest
                                           (= i 1) :knight
                                           :else :peasant)))))
     :edges {[:cold :fire] 0.60
             [:trees :fire] 0.45
             [:lightning :storm] 0.70
             [:storm :deity/storm] 0.80
             [:fire :patron/fire] 0.80
             [:patron/fire :judgment] 0.35
             [:deity/storm :awe] 0.25
             [:judgment :awe] 0.25}
     :ledger {}
     :recent-events []
     :recent-max 30
     :traces []
     :trace-max 250}))

(defn process-jobs!
  "Process jobs for agents: advance progress if adjacent to target."
  [world]
  (reduce
     (fn [w agent-id]
       (if-let [job (jobs/get-agent-job w agent-id)]
         (let [agent-pos (get-in w [:agents agent-id :pos])
               job-target (:target job)
               delta (if (<= (hex/distance agent-pos job-target) 1)
                       0.2
                       0.0)]
           (jobs/advance-job! w agent-id delta))
         w))
     world
     (range (count (:agents world)))))

(defn- parse-tile-key
   "Parse a tile key string 'q,r' into [q r] coordinate vector."
   [k]
   (let [parts (str/split k #",")]
     [(Integer/parseInt (first parts)) (Integer/parseInt (second parts))]))

(defn spawn-initial-trees!
  "Spawn initial trees randomly throughout the map. Approximately 5% of tiles get trees."
  [world]
  (let [r (rng (:seed world))
        hex-map (:map world)
        bounds (:bounds hex-map)
        spawn-chance 0.05]
    (if (= (:shape bounds) :rect)
      (let [w (long (:w bounds 1))
            h (long (:h bounds 1))
            origin (:origin bounds [0 0])]
        (reduce
          (fn [w' q]
            (reduce
              (fn [w'' r]
                (if (< (rand-int* r 1000) (int (* spawn-chance 1000)))
                  (let [pos [(+ (first origin) q) (+ (second origin) r)]
                        tile-key (str (first pos) "," (second pos))]
                    (assoc-in w'' [:tiles tile-key]
                              {:terrain :ground :resource :tree :last-fruit-drop 0
                               :next-spread-tick (+ (:tick w'') 20 (rand-int* r 141))}))
                  w''))
              w'
              (range h)))
          world
          (range w)))
      world)))

(defn spread-trees!
   "Spread trees to adjacent empty tiles. Each tree has a chance to spawn a new tree
    in an adjacent empty tile every 20-160 ticks."
   [world]
   (let [current-tick (:tick world)
         r (rng (:seed world))
         min-interval 20
         max-interval 160]
     (reduce-kv
      (fn [w tile-key tile]
        (if (= (:resource tile) :tree)
          (let [next-spread (or (:next-spread-tick tile) (+ current-tick min-interval (rand-int* r (- max-interval min-interval))))
                should-spread? (>= current-tick next-spread)]
            (if should-spread?
              (let [pos (parse-tile-key tile-key)
                    neighbors (hex/neighbors pos)
                    valid-neighbors (filter (fn [n] (and (hex/in-bounds? (:map w) n)
                                                          (nil? (get-in w [:tiles (str (first n) "," (second n))]))))
                                            neighbors)]
                (if (seq valid-neighbors)
                  (let [new-pos (rand-nth valid-neighbors)
                        new-tile-key (str (first new-pos) "," (second new-pos))]
                    (-> w
                        (assoc-in [:tiles new-tile-key]
                                  {:terrain :ground :resource :tree :last-fruit-drop 0
                                   :next-spread-tick (+ current-tick min-interval (rand-int* r (- max-interval min-interval)))})
                        (assoc-in [:tiles tile-key :next-spread-tick]
                                  (+ current-tick min-interval (rand-int* r (- max-interval min-interval))))))
                  (assoc-in w [:tiles tile-key :next-spread-tick]
                            (+ current-tick min-interval (rand-int* r (- max-interval min-interval))))))))
      world
      (:tiles world))))

(defn drop-tree-fruits!
  "Process fruit dropping for all trees. Each tree drops fruit randomly every 5-20 turns.
   Fruits accumulate at the tree position in the :items map."
  [world]
  (let [current-tick (:tick world)
        rng (rng (:seed world))]
    (reduce-kv
     (fn [w tile-key tile]
       (if (= (:resource tile) :tree)
         (let [last-drop (or (:last-fruit-drop tile) 0)
               turns-since (- current-tick last-drop)
               min-interval 5
               max-interval 20
               interval-range (+ 1 (- max-interval min-interval))
               drop-at (+ last-drop min-interval (mod (rand-int* rng 1000000) interval-range))]
           (if (>= turns-since min-interval)
             (let [should-drop? (>= turns-since (or (:next-fruit-drop tile) drop-at))]
               (cond-> w
                 should-drop?
                 (as-> w'
                   (let [pos (parse-tile-key tile-key)]
                     (-> w'
                         (jobs/add-item! pos :fruit 1)
                         (assoc-in [:tiles tile-key :last-fruit-drop] current-tick)
                         (assoc-in [:tiles tile-key :next-fruit-drop] (+ current-tick min-interval (mod (rand-int* rng 1000000) interval-range))))))))
             w))
         w))
     world
     (:tiles world))))

(defn move-agent-with-job
   "Move an agent one step. If agent has job, use pathing toward target.
    Otherwise, use random movement."
   [world agent]
   (if-let [job (jobs/get-agent-job world (:id agent))]
     (let [current-pos (:pos agent)
           job-target (:target job)]
       (if (= current-pos job-target)
         agent
         (let [next-pos (pathing/next-step-toward world current-pos job-target)]
           (if (not= next-pos current-pos)
             (assoc agent :pos next-pos)
             agent))))
     (spatial/move-agent world agent)))

 (defn tick-once [world]
    (let [t (inc (:tick world))
           w1 (assoc world :tick t)
            w2 (-> w1
                    (jobs/auto-generate-jobs!)
                    (jobs/auto-assign-jobs!)
                    (process-jobs!)
                    (drop-tree-fruits!))
           agents1 (->> (:agents w2)
                        (map (fn [a]
                               (agents/update-needs w2
                                                    (move-agent-with-job w2 a))))
                        vec)
         ev (runtime/generate w2 agents1)
        ev-step (if ev
                  (reduce
                    (fn [{:keys [agents mentions traces]} a]
                      (if (contains? (set (:witnesses ev)) (:id a))
                        (let [res (runtime/apply-to-witness w2 a ev)]
                          {:agents (conj agents (:agent res))
                           :mentions (into mentions (:mentions res))
                           :traces (into traces (:traces res))})
                        {:agents (conj agents a)
                         :mentions mentions
                         :traces traces}))
                    {:agents [] :mentions [] :traces []}
                    agents1)
                  {:agents agents1 :mentions [] :traces []})
         agents2 (:agents ev-step)
         pairs (agents/interactions agents2)
         talk-step (reduce
                    (fn [{:keys [agents mentions traces]} [speaker listener]]
                      (let [packet (agents/choose-packet w2 speaker)
                            res (agents/apply-packet-to-listener w2 listener speaker packet)
                            agents' (assoc agents (:id listener) (:listener res))]
                        {:agents agents'
                         :mentions (into mentions (:mentions res))
                         :traces (into traces (:traces res))}))
                   {:agents (vec agents2)
                    :mentions (:mentions ev-step)
                    :traces (:traces ev-step)}
                   pairs)
         agents3 (:agents talk-step)
         bcasts (institutions/broadcasts w2)
         inst-step (reduce
                    (fn [{:keys [agents mentions traces]} b]
                      (let [res (institutions/apply-broadcast w2 agents b)]
                        {:agents (:agents res)
                         :mentions (into mentions (:mentions res))
                         :traces (into traces (:traces res))}))
                   {:agents agents3
                    :mentions (:mentions talk-step)
                    :traces (:traces talk-step)}
                   bcasts)
         agents4 (:agents inst-step)
         ledger-info (world/update-ledger w2 (:mentions inst-step))
         ledger2 (:ledger ledger-info)
         attr (:attribution ledger-info)
         recent' (if ev
                   (->> (concat (:recent-events w2)
                                [(select-keys ev [:id :type :tick :pos :impact :witness-score :witnesses])])
                        (take-last (:recent-max w2))
                        vec)
                   (:recent-events w2))
         traces' (->> (concat (:traces w2) (:traces inst-step))
                      (take-last (:trace-max w2))
                      vec)
         world' (-> w2
                    (assoc :agents agents4)
                    (assoc :ledger ledger2)
                    (assoc :recent-events recent')
                    (assoc :traces traces'))]
     {:world world'
      :out {:tick t
            :event ev
            :mentions (:mentions inst-step)
            :traces (:traces inst-step)
            :attribution attr
            :snapshot (world/snapshot world' attr)}}))

(defonce *state (atom (initial-world 1)))

(defn get-state [] @*state)

(defn reset-world!
  ([] (reset-world! {}))
  ([opts]
   (clojure.core/reset! *state (initial-world opts))))

(defn set-levers! [levers]
  (swap! *state update :levers merge levers))

(defn place-shrine! [pos]
  (swap! *state assoc :shrine pos))

(defn appoint-mouthpiece! [agent-id]
  (swap! *state assoc-in [:levers :mouthpiece-agent-id] agent-id))

(defn assign-build-wall-job!
   "Manually assign a build-wall job to an agent at a specific position."
   [agent-id pos]
   (let [world @*state]
     (when (get-in world [:agents agent-id])
       (let [job (jobs/create-job :job/build-wall pos)]
         (swap! *state jobs/assign-job! job agent-id)))))

(defn move-agent-with-job
   "Move an agent one step. If agent has job, use pathing toward target.
    Otherwise, use random movement."
   [world agent]
   (if-let [job (jobs/get-agent-job world (:id agent))]
     (let [current-pos (:pos agent)
           job-target (:target job)]
       (if (= current-pos job-target)
         agent
         (let [next-pos (pathing/next-step-toward world current-pos job-target)]
           (if (not= next-pos current-pos)
             (assoc agent :pos next-pos)
             agent))))
     (spatial/move-agent world agent)))

(defn place-wall-ghost! [pos]
  (let [world @*state
        [q r] pos
        tile-key (str q "," r)
        tile (get-in world [:tiles tile-key])]
    (when (and (hex/in-bounds? (:map world) pos)
               (nil? (:structure tile)))
      (swap! *state assoc-in [:tiles tile-key]
             {:terrain :ground :structure :wall-ghost :resource nil}))))

(defn place-stockpile! [pos resource max-qty]
  (let [world @*state
        [q r] pos
        tile-key (str q "," r)
        tile (get-in world [:tiles tile-key])]
    (when (and (hex/in-bounds? (:map world) pos)
               (nil? (:structure tile))
               (nil? (get-in world [:stockpiles tile-key])))
      (swap! *state jobs/create-stockpile! pos resource (or max-qty 100)))))

(defn tick! [n]
  (loop [i 0
         outs []]
    (if (>= i n)
      outs
      (let [{:keys [world out]} (tick-once (get-state))]
        (clojure.core/reset! *state world)
        (recur (inc i) (conj outs out))))))
