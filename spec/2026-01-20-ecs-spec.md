# ECS Migration Specification

## Executive Summary

Migrate simulation from map-based entity representation to proper Entity-Component-System (ECS) architecture.

**Key Principles**:
- **Components** = Pure data records (defrecord)
- **Entities** = UUID-identified collections of components
- **Systems** = Pure functions that query and update components
- **Jobs** = Components of building entities (not independent entities)

**Timeline**: 7 weeks total, starting with Phase 1

---

## 1. Component Specifications

### 1.1 Core Position Components

```clojure
(defrecord Position [q r])

(defrecord TileIndex [q r])
```

**Rationale**:
- Use vector `[q r]` as keys instead of strings `"q,r"`
- `TileIndex` component stores the position for O(1) tile lookups
- Backward compatibility: adapter can convert string keys

**Migration**:
1. Change all tile key generation from `(str q "," r)` to `[q r]`
2. Update all tile lookups to use vector keys
3. Keep `TileIndex` component for entity-based queries

---

### 1.2 Agent Components

#### 1.2.1 Identity

```clojure
(defrecord AgentInfo [id name])
```

**Fields**:
- `id`: Integer agent ID (for backward compat)
- `name`: String "agent-123" (for display)

**Usage**: All agent entities have this component

---

#### 1.2.2 Role

```clojure
(defrecord Role [type])
```

**Fields**:
- `type`: Keyword - `:priest`, `:peasant`, `:knight`, `:wolf`, `:bear`, etc.

**Existing**: Keep as-is

---

#### 1.2.3 Needs

```clojure
(defrecord Needs
  [warmth food sleep
   water health security mood
   hunger-axis     ;; Maps to :food for backward compat
   security-axis    ;; New axis for danger/safety queries
   rest-axis        ;; Maps to :sleep for backward compat
   warmth-axis     ;; Maps to :warmth for backward compat
   health-axis      ;; New axis
   mood-axis])      ;; New axis
```

**Existing**: Keep as-is, already well-designed

---

#### 1.2.4 Inventory

```clojure
(defrecord PersonalInventory [wood food items])
```

**Fields**:
- `wood`: Integer - wood quantity carried
- `food`: Integer - food quantity carried
- `items`: Map - `{resource-type: qty}` for other items

**Rationale**: 
- Replace `:inventory {:wood 0 :food 0}` pattern
- Support additional item types via `items` map

**Migration**:
- Replace `Inventory` record
- Update agent factories to use `PersonalInventory`

---

#### 1.2.5 Status

```clojure
(defrecord AgentStatus [alive? asleep? idle? cause-of-death])
```

**Fields**:
- `alive?`: Boolean - agent is alive
- `asleep?`: Boolean - agent is sleeping
- `idle?`: Boolean - agent has no job
- `cause-of-death`: Keyword/nil - `:starvation`, `:health-critical`, etc.

**Rationale**:
- Extract from nested `:status {:alive? true ...}` maps
- Enable querying `alive?` agents directly

**Migration**:
- Create `AgentStatus` component
- Replace nested status maps with component

---

#### 1.2.6 Belief and Memory

```clojure
(defrecord Frontier [facets])
(defrecord Recall [events])
```

**Existing**: Keep as-is, already well-designed

---

#### 1.2.7 Movement

```clojure
(defrecord Path [waypoints current-index])
```

**Fields**:
- `waypoints`: Vector of `[q r] positions
- `current-index`: Integer - current position in path

**Existing**: Keep as-is

---

### 1.3 Tile Components

#### 1.3.1 Core Tile

```clojure
(defrecord Tile [terrain biome structure resource])
```

**Fields**:
- `terrain`: Keyword - `:ground`, `:water`, etc.
- `biome`: Keyword - `:plains`, `:forest`, `:mountains`, etc.
- `structure`: Keyword - `:campfire`, `:house`, `:wall`, `:lumberyard`, etc.
- `resource`: Keyword - `:tree`, `:fruit`, `:rock`, or nil

**Existing**: Keep as-is

---

#### 1.3.2 Tile Resources

```clojure
(defrecord TileResources [items last-fruit-drop next-fruit-drop-tick])
```

**Fields**:
- `items`: Map - `{resource-type: qty}` of items on this tile
- `last-fruit-drop`: Integer - tick when fruit last dropped
- `next-fruit-drop-tick`: Integer - tick for next scheduled fruit drop

**Rationale**:
- Replace scattered fruit/timber data in tile maps
- Enable regrowth and drop systems

**Migration**:
- Extract fruit/timber state from tile maps
- Move to `TileResources` component

---

#### 1.3.3 Structure State

```clojure
(defrecord StructureState [level health max-health owner-id])
```

**Fields**:
- `level`: Integer - building level (1-3)
- `health`: Integer - current health (0-100)
- `max-health`: Integer - maximum health (usually 100)
- `owner-id`: UUID - agent/entity that owns this structure

**Rationale**:
- Support structure damage/repair mechanics
- Track structure levels for improvement jobs

**Migration**:
- Add to tiles with structures
- Initialize with default values

---

#### 1.3.4 Special Tile States

```clojure
(defrecord CampfireState [warmth-range active? last-fueled-tick])
(defrecord ShrineState [mouthpiece-agent-id])
```

**CampfireState Fields**:
- `warmth-range`: Integer - hex radius (default 2)
- `active?`: Boolean - campfire is lit
- `last-fueled-tick`: Integer - when last fueled

**ShrineState Fields**:
- `mouthpiece-agent-id`: UUID - agent acting as mouthpiece

**Rationale**:
- Store dynamic state for special tiles
- Enable campfire fueling mechanics

**Migration**:
- Add conditionally to relevant tiles
- Initialize from old-style state

---

### 1.4 Job Components

**Decision**: Jobs are **components of building entities**, not independent entities.

#### 1.4.1 Job Queue Component

```clojure
(defrecord JobQueue [pending-jobs assigned-jobs])
```

**Fields**:
- `pending-jobs`: Vector of job maps - jobs waiting for workers
- `assigned-jobs`: Map of `{agent-id: job}` - active jobs

**Rationale**:
- Buildings generate jobs and maintain their queue
- Jobs remain simple maps (no separate entity overhead)
- Building entities control their job lifecycle

**Job Map Structure**:
```clojure
{:id UUID
 :type Keyword           ;; :job/chop-tree, :job/build-house, etc.
 :target [Integer Integer] ;; Position [q r]
 :worker-id UUID/nil
 :progress Double
 :required Double
 :state Keyword          ;; :pending, :claimed, :in-progress, :completed
 :priority Integer
 :metadata Map          ;; Job-specific data (resource, qty, stage, etc.)
}
```

**Usage Examples**:

**Lumberyard (job provider)**:
```
Entity: #uuid "lumberyard-5,10"
  ├─ Position {q: 5, r: 10}
  ├─ Tile {structure: :lumberyard, ...}
  ├─ StructureState {level: 2, ...}
  └─ JobQueue {
       pending-jobs: [{:type :job/harvest-wood, target: [8 12], ...}],
       assigned-jobs: {#uuid "agent-1": {:type :job/harvest-wood, ...}}
     }
```

**Agent (job worker)**:
```
Entity: #uuid "agent-1"
  ├─ Position {q: 3, r: 5}
  ├─ Role {type: :peasant}
  ├─ JobAssignment {job-id: #uuid "job-abc", progress: 0.3}
  └─ ...
```

**Migration**:
1. Create `JobQueue` component
2. Move job generation from global to building entities
3. Building systems manage their job queues
4. Agent `JobAssignment` component references job by ID

---

### 1.5 Inventory Components

#### 1.5.1 Stockpile Inventory

```clojure
(defrecord StockpileInventory [resource max-qty current-qty items])
```

**Fields**:
- `resource`: Keyword - primary stored resource (:log, :fruit, :grain, :rock)
- `max-qty`: Integer - capacity (default 120)
- `current-qty`: Integer - current amount
- `items`: Map - `{resource-type: qty}` for mixed storage

**Rationale**:
- Replace map-based stockpiles
- Support multiple resources per stockpile
- Enable efficient queries

**Migration**:
- Convert `(:stockpiles "5,10" {:resource :log ...})` to entities
- Add `StockpileInventory` component

---

#### 1.5.2 World Item Entities (NEW)

```clojure
(defrecord WorldItem [resource qty pos created-at])
```

**Fields**:
- `resource`: Keyword - type of item
- `qty`: Integer - quantity
- `pos`: [q r] - position on map
- `created-at`: Integer - tick when dropped

**Entity Structure**:
```
Entity: #uuid "item-123"
  ├─ Position {q: 5, r: 10}
  ├─ WorldItem {resource: :log, qty: 3, pos: [5 10], created-at: 100}
  └─ ...
```

**Rationale**:
- Represent dropped items as entities
- Enable item decay/cleanup systems
- Support complex item interactions

**Migration**:
- Convert `:items` map to entity list
- Create entities for each dropped item
- Remove old `:items` map

---

### 1.6 Global State (Not Components)

**These remain as top-level maps**, not ECS components:

```clojure
(defrecord SimulationState [tick seed temperature daylight cold-snap calendar])
(defrecord Levers [iconography mouthpiece-agent-id])
(defrecord WorldConfig [map-bounds initial-tree-density])
(defrecord EventLedger [ledger attribution])
(defrecord EventHistory [recent-events recent-max traces trace-max])
```

**Rationale**:
- These are global simulation state, not entity-specific
- Keep outside ECS for simplicity
- Accessed by all systems but don't vary per entity

---

## 2. Entity Factory Specifications

### 2.1 Agent Factory

```clojure
(defn create-agent
  "Create an agent entity with standard components."
  [system id q r role opts]
  (let [entity-id (or id (java.util.UUID/randomUUID))
        {:keys [warmth food sleep wood]} opts
        {:keys [needs status inventory frontier recall path job-id]} opts
        system' (-> system
                      (be/add-entity entity-id)
                      (be/add-component entity-id (c/->Position q r))
                      (be/add-component entity-id (c/->AgentInfo id (str "agent-" id)))
                      (be/add-component entity-id (c/->Role role))
                      (be/add-component entity-id (c/->Needs warmth food sleep ...))
                      (be/add-component entity-id (c/->PersonalInventory wood food {}))
                      (be/add-component entity-id (c/->AgentStatus true false false nil))
                      (be/add-component entity-id (c/->Frontier (or frontier {})))
                      (be/add-component entity-id (c/->Recall (or recall {})))
                      (cond-> job-id
                        (be/add-component entity-id (c/->JobAssignment job-id 0.0)))
                      (cond-> path
                        (be/add-component entity-id (c/->Path path 0)))))]
    [entity-id system']))
```

**Parameters**:
- `id`: Optional integer ID (for backward compat)
- `q`, `r`: Hex coordinates
- `role`: Agent type keyword
- `opts`: Map of optional overrides

**Returns**: `[entity-id updated-system]`

---

### 2.2 Tile Factory

```clojure
(defn create-tile
  "Create a tile entity with optional components."
  [system [q r] terrain biome structure resource opts]
  (let [entity-id (java.util.UUID/randomUUID)
        {:keys [tile-resources structure-state campfire-state shrine-state]} opts
        system' (-> system
                      (be/add-entity entity-id)
                      (be/add-component entity-id (c/->Position q r))
                      (be/add-component entity-id (c/->TileIndex [q r]))
                      (be/add-component entity-id (c/->Tile terrain biome structure resource))
                      (cond-> tile-resources
                        (be/add-component entity-id tile-resources))
                      (cond-> structure-state
                        (be/add-component entity-id structure-state))
                      (cond-> campfire-state
                        (be/add-component entity-id campfire-state))
                      (cond-> shrine-state
                        (be/add-component entity-id shrine-state))))]
    [entity-id system']))
```

**Conditional Components**:
- `TileResources`: Add for tiles with resources (trees, fruits)
- `StructureState`: Add for tiles with structures
- `CampfireState`: Add for campfire tiles only
- `ShrineState`: Add for shrine tiles only

---

### 2.3 Building Factory

```clojure
(defn create-building
  "Create a building entity (job provider) with JobQueue."
  [system [q r] structure-type opts]
  (let [entity-id (java.util.UUID/randomUUID)
        {:keys [level health owner-id stockpile-config job-queue]} opts
        structure-state (c/->StructureState 
                            (or level 1) 
                            (or health 100) 
                            (or health 100)
                            owner-id)
        system' (-> system
                      (be/add-entity entity-id)
                      (be/add-component entity-id (c/->Position q r))
                      (be/add-component entity-id (c/->TileIndex [q r]))
                      (be/add-component entity-id (c/->Tile :ground :plains structure-type nil))
                      (be/add-component entity-id structure-state)
                      (cond-> stockpile-config
                        (be/add-component entity-id (c/->StockpileInventory 
                                                  (:resource stockpile-config)
                                                  (:max-qty stockpile-config)
                                                  0
                                                  {})))
                      (be/add-component entity-id (c/->JobQueue [] {})))]
    [entity-id system']))
```

**Job Providers**:
- Lumberyard: `:structure-type :lumberyard`
- Orchard: `:structure-type :orchard`
- Granary: `:structure-type :granary`
- Quarry: `:structure-type :quarry`
- Workshop: `:structure-type :workshop`
- Smelter: `:structure-type :smelter`
- Improvement Hall: `:structure-type :improvement-hall`

**Usage**:
```clojure
(create-building system [5 10] :lumberyard
               {:level 2
                :stockpile-config {:resource :log :max-qty 120}
                :job-queue {:pending-jobs [...] :assigned-jobs {}}})
```

---

### 2.4 World Item Factory

```clojure
(defn create-world-item
  "Create a dropped item entity."
  [system [q r] resource qty]
  (let [entity-id (java.util.UUID/randomUUID)
        tick (:tick (get-global-state))
        system' (-> system
                      (be/add-entity entity-id)
                      (be/add-component entity-id (c/->Position q r))
                      (be/add-component entity-id (c/->WorldItem resource qty [q r] tick)))]
    [entity-id system']))
```

---

## 3. System Specifications

### 3.1 System Execution Order

```clojure
(defn run-tick
  "Execute all systems in dependency order."
  [ecs-world global-state]
  (-> ecs-world
      (world-systems/spread-trees global-state)
      (world-systems/drop-fruits global-state)
      (world-systems/maintain-structures)
      (agent-systems/process-needs-decay global-state)
      (agent-systems/process-movement global-state)
      (agent-systems/process-agent-actions global-state)
      (job-systems/generate-jobs global-state)
      (job-systems/assign-jobs global-state)
      (job-systems/progress-jobs global-state)
      (job-systems/complete-jobs global-state)
      (social-systems/process-communication global-state)
      (social-systems/update-frontiers global-state)
      (social-systems/process-memories global-state)
      (event-systems/generate-events global-state)
      (cleanup-systems/remove-expired-components global-state)
      (cleanup-systems/remove-dead-agents global-state)))
```

**Dependencies**:
- World systems run first (map updates)
- Agent systems depend on world state
- Job systems depend on agent state
- Social systems depend on agent state
- Cleanup systems run last

---

### 3.2 World Systems

#### 3.2.1 Tree Spread System

**Location**: `fantasia.sim.ecs.systems/world/trees`

```clojure
(defn spread-trees
  "Spawn new trees in neighbors of existing trees."
  [ecs-world tick seed tree-density]
  (let [tree-tiles (query-tiles-with-resource ecs-world :tree)
        world-config (get-world-config ecs-world)]
    (reduce (fn [acc [q r]]
              (if (should-spawn-tree? acc [q r] tick seed tree-density)
                (create-tree-tile acc [q r] tick seed)
                acc))
            ecs-world
            (get-neighbor-positions tree-tiles world-config))))
```

---

#### 3.2.2 Fruit Drop System

```clojure
(defn drop-fruits
  "Drop fruits from trees when ready."
  [ecs-world tick seed]
  (let [tree-tiles (query-tiles-with-resource ecs-world :tree)
        ready-tiles (filter #(ready-to-drop? % tick) tree-tiles)]
    (reduce (fn [acc tile-entity-id]
              (drop-fruit-into-items acc tile-entity-id tick seed))
            ecs-world
            ready-tiles)))
```

---

### 3.3 Job Systems

#### 3.3.1 Job Generation

**Location**: `fantasia.sim.ecs.systems/jobs/generation`

```clojure
(defn generate-jobs
  "Buildings generate jobs based on world state."
  [ecs-world global-state]
  (let [job-provider-entities (query-buildings-with-job-queue ecs-world)
        tick (:tick global-state)]
    (reduce (fn [acc entity-id]
              (update-building-jobs acc entity-id global-state))
            ecs-world
            job-provider-entities)))
```

**Building Types**:
- Lumberyard generates `:job/harvest-wood`
- Orchard generates `:job/harvest-fruit`
- Granary generates `:job/harvest-grain`
- Quarry generates `:job/mine`
- Workshop generates `:job/build-structure`
- Smelter generates `:job/smelt`

---

#### 3.3.2 Job Assignment

```clojure
(defn assign-jobs
  "Assign pending jobs to available agents."
  [ecs-world global-state]
  (let [available-agents (query-available-agents ecs-world)
        all-jobs (query-all-pending-jobs ecs-world)]
    (let [assignments (find-optimal-assignments available-agents all-jobs global-state)]
      (reduce (fn [acc [agent-id job]]
                (assign-job-to-agent acc agent-id job))
              ecs-world
              assignments))))
```

---

#### 3.3.3 Job Progress

```clojure
(defn progress-jobs
  "Advance progress for in-progress jobs."
  [ecs-world delta]
  (let [agents-with-jobs (query-agents-with-job-assignment ecs-world)]
    (reduce (fn [acc agent-id]
              (if (at-job-target? acc agent-id global-state)
                (advance-job-progress acc agent-id delta)
                acc))
            ecs-world
            agents-with-jobs)))
```

---

#### 3.3.4 Job Completion

```clojure
(defn complete-jobs
  "Execute job completion, update building JobQueues."
  [ecs-world global-state]
  (let [completed-jobs (query-completed-jobs ecs-world)]
    (reduce (fn [acc [agent-id job-id]]
              (execute-job-completion acc agent-id job-id global-state))
            ecs-world
            completed-jobs)))
```

**Job Completion Actions**:
- Update building `JobQueue`
- Update agent inventory/needs
- Create/remove world items
- Update tile resources/structures

---

### 3.4 Query Helper Specifications

#### 3.4.1 Component Query Helpers

```clojure
(defn query-tiles-with-resource
  "Get all tile entities with specific resource."
  [ecs-world resource-type]
  (let [tile-type (be/get-component-type (c/->Tile :ground :plains nil resource-type))
        tiles (be/get-all-entities-with-component ecs-world tile-type)]
    (filter #(has-resource? ecs-world % resource-type) tiles)))

(defn query-buildings-with-job-queue
  "Get all building entities (job providers)."
  [ecs-world]
  (let [job-queue-type (be/get-component-type (c/->JobQueue [] {}))
        building-types #{:lumberyard :orchard :granary :quarry :workshop :smelter :improvement-hall}
        tile-type (be/get-component-type (c/->Tile :ground :plains nil nil))]
    (filter #(and (has-component? ecs-world % tile-type)
                   (has-component? ecs-world % job-queue-type)
                   (building-types (:structure (get-tile ecs-world %))))
            (be/get-all-entities ecs-world))))

(defn query-available-agents
  "Get all alive, idle agents."
  [ecs-world]
  (let [status-type (be/get-component-type (c/->AgentStatus true false false nil))
        job-assignment-type (be/get-component-type (c/->JobAssignment nil 0.0))]
    (filter #(and (has-component? ecs-world % status-type)
                   (not (has-component? ecs-world % job-assignment-type)))
            (be/get-all-entities ecs-world))))
```

---

## 4. Adapter Specifications

### 4.1 ECS to Snapshot Adapter

```clojure
(defn ecs->snapshot
  "Convert ECS world to snapshot format for WebSocket broadcast."
  [ecs-world global-state]
  {:tick (:tick global-state)
   :shrine (:shrine global-state)
   :levers (:levers global-state)
   :map (:map global-state)
   :tiles (ecs->tiles-map ecs-world)
   :recent-events (:recent-events global-state)
   :attribution (:attribution global-state)
   :jobs (ecs->jobs-map ecs-world)
   :stockpiles (ecs->stockpiles-map ecs-world)
   :agents (ecs->agent-list ecs-world)
   :ledger (:ledger global-state)})

(defn ecs->jobs-map
  "Convert building JobQueues to old-style jobs map."
  [ecs-world]
  (let [buildings (query-buildings-with-job-queue ecs-world)]
    (reduce (fn [acc building-id]
              (let [job-queue (get-job-queue ecs-world building-id)
                    all-jobs (concat (:pending-jobs job-queue)
                                      (vals (:assigned-jobs job-queue)))]
                (into acc (map #(vector (:id %) %) all-jobs))))
            {} 
            buildings)))
```

---

## 5. Migration Steps

### Phase 1: Foundation (Week 1)

#### Step 1.1: Add Missing Components

**File**: `backend/src/fantasia/sim/ecs/components.clj`

**Additions**:
- `AgentInfo`
- `AgentStatus`
- `PersonalInventory`
- `TileResources`
- `StructureState`
- `CampfireState`
- `ShrineState`
- `JobQueue`
- `WorldItem`

---

#### Step 1.2: Update Entity Factories

**File**: `backend/src/fantasia/sim/ecs/core.clj`

**Updates**:
1. Expand `create-agent` to use all agent components
2. Expand `create-tile` to support optional components
3. Add `create-building` function (NEW)
4. Add `create-world-item` function (NEW)

---

#### Step 1.3: Update Adapter

**File**: `backend/src/fantasia/sim/ecs/adapter.clj`

**Updates**:
1. Update `ecs->agent-map` to include new components
2. Update `ecs->tile-map` to include `TileResources`, `StructureState`
3. Add `ecs->jobs-map` to aggregate building `JobQueue`s
4. Add `ecs->stockpiles-map` conversion

---

#### Step 1.4: Tile Key Migration

**Strategy**: Gradual migration with compatibility layer

**File**: `backend/src/fantasia/sim/ecs/core.clj`

**Additions**:
```clojure
(defn tile-key [[q r]] [q r])
(defn parse-tile-key [[q r]] [q r])

(defn tile-key->string [[q r]] (str q "," r))
(defn string->tile-key [s] (mapv #(Integer/parseInt %) (clojure.string/split s #",")))
```

**Migration Path**:
1. Keep `TileIndex` component storing vector key
2. Adapter converts to/from string for WebSocket compatibility
3. Gradually update internal code to use vectors

---

## 6. Testing Specifications

### 6.1 Component Tests

**File**: `test/fantasia/sim/ecs/components_test.clj`

```clojure
(deftest tile-index-component-uses-vectors
  (let [tile-index (c/->TileIndex [5 10])]
    (is (= [5 10] (:entity-id tile-index)))))

(deftest job-queue-component-stores-jobs
  (let [job-queue (c/->JobQueue 
                                      [{:id (random-uuid) :type :job/chop-tree}] 
                                      {(random-uuid) {:id (random-uuid)}}])]
    (is (= 1 (count (:pending-jobs job-queue))))
    (is (= 1 (count (:assigned-jobs job-queue))))))
```

---

### 6.2 Factory Tests

**File**: `test/fantasia/sim/ecs/factory_test.clj`

```clojure
(deftest create-building-with-job-queue
  (let [[entity-id system] (create-builder (create-ecs-world) [5 10] :lumberyard)]
        job-queue (get-job-queue system entity-id)]
    (is (some? job-queue))
    (is (instance? c/JobQueue job-queue))))

(deftest create-world-item-entity
  (let [[entity-id system] (create-world-item (create-ecs-world) [5 10] :log 3)]
        position (get-position system entity-id)
        world-item (get-world-item system entity-id)]
    (is (= [5 10] (:q position)))
    (is (= :log (:resource world-item)))
    (is (= 3 (:qty world-item)))))
```

---

### 6.3 Integration Tests

**File**: `test/fantasia/sim/ecs/integration_test.clj`

```clojure
(deftest building-generates-job
  (let [system (create-ecs-world)
        [building-id system'] (create-builder system [5 10] :lumberyard)
        system'' (job-systems/generate-jobs system' global-state)
        job-queue (get-job-queue system'' building-id)]
    (is (> (count (:pending-jobs job-queue)) 0))))

(deftest agent-accepts-job
  (let [system (create-ecs-world)
        [building-id system'] (create-builder system [5 10] :lumberyard)
        [agent-id system''] (create-agent system 1 3 5 :peasant {})
        system'' (job-systems/generate-jobs system' global-state)
        system''' (job-systems/assign-jobs system'' global-state)
        agent-job (get-job-assignment system''' agent-id)]
    (is (some? agent-job))))
```

---

## 7. Data Structures

### 7.1 Vector-Based Tile Indexing

**Old Style**:
```clojure
{:tiles {"5,10" {...} "5,11" {...}}}
```

**New Style**:
```
Entity: #uuid "tile-5,10"
  ├─ Position {q: 5, r: 10}
  └─ TileIndex [5 10]
```

**Lookup**:
```clojure
(defn get-tile-at-pos
  [ecs-world [q r]]
  (let [position-type (be/get-component-type (c/->Position 0 0))
        tile-index-type (be/get-component-type (c/->TileIndex [0 0]))
        entities-with-position (be/get-all-entities-with-component ecs-world position-type)
        entities-with-index (be/get-all-entities-with-component ecs-world tile-index-type)]
    (first (filter #(= [q r] (:entity-id (get-tile-index ecs-world % tile-index-type)))
                   entities-with-index))))
```

**Performance**: O(n) worst case, can optimize with spatial index

---

### 7.2 Job Lifecycle

**Old Style**:
```clojure
{:jobs [...]
 :jobs-by-id {job-id job}}
```

**New Style**:
```
Building Entity: #uuid "lumberyard-5,10"
  └─ JobQueue {
       pending-jobs [job-1 job-2 ...]
       assigned-jobs {agent-1: job-1 agent-2: job-2}
     }

Agent Entity: #uuid "agent-1"
  └─ JobAssignment {job-id: #uuid "job-1", progress: 0.3}
```

**Benefits**:
- Building owns its job lifecycle
- Agent only references assigned job by ID
- No global job index needed
- Building can implement job prioritization logic

---

## 8. Performance Considerations

### 8.1 Component Query Optimization

**Pattern**: Cache component types

```clojure
(defonce cached-component-types
  (delay
    {:position (be/get-component-type (c/->Position 0 0))
     :role (be/get-component-type (c/->Role :priest))
     ;; ... cache all types
     }))
```

**Usage**: 
```clojure
(defn query-agents
  [ecs-world]
  (let [position-type (:position @cached-component-types)
        role-type (:role @cached-component-types)]
    (be/get-all-entities-with-component ecs-world position-type)))
```

---

### 8.2 Batch Updates

**Pattern**: Process multiple entities in single pass

```clojure
(defn process-needs-batch
  [ecs-world global-state]
  (let [needs-type (be/get-component-type (c/->Needs 0.6 0.7 0.7 ...))
        agent-ids (be/get-all-entities-with-component ecs-world needs-type)
        cold-snap (or (:cold-snap global-state) 0.5)]
    (reduce (fn [acc agent-id]
              (decay-agent-needs acc agent-id cold-snap))
            ecs-world
            agent-ids)))
```

---

## 9. Open Questions & Decisions

### Q1: Tile Keys - Answered ✓
**Decision**: Use vectors `[q r]` as keys
- `TileIndex` component stores vector
- Adapter handles string conversion for WebSocket
- Embeddings remain string-based (unchanged)

---

### Q2: Jobs as Components - Answered ✓
**Decision**: Jobs are components of building entities
- Building entities have `JobQueue` component
- Agent entities have `JobAssignment` component
- Jobs remain simple maps, stored in `JobQueue`

**Rationale**:
- Buildings control job lifecycle
- Simpler than full job entities
- Natural fit for job provider pattern
- Enables building-specific job logic

---

### Q3: Thread Safety - Answered ✓
**Decision**: Use atom for ECS world
- Keep existing `*ecs-world` atom pattern
- No STM ref needed (single writer model)
- Future parallelism: system-level parallelization only

**Rationale**:
- Simpler than STM
- Matches current patterns
- Adequate for simulation workload

---

### Q4: Query DSL - Deferred
**Decision**: Use helper functions over Brute queries initially
- Helper functions like `query-agents`, `query-buildings`
- Can add DSL later if needed
- Keep dependency low for Phase 1

---

### Q5: Parallelism - Deferred ✓
**Decision**: Profile first, optimize later
- Single-threaded tick for now
- Identify bottlenecks with profiling
- Add `pmap` for independent systems if needed
- System-level parallelization only (no component-level concurrency)

---

## 10. Success Criteria

### 10.1 Code Quality

- [ ] All components defined in `ecs/components.clj`
- [ ] All entity factories complete
- [ ] All systems are pure functions
- [ ] No deep nesting in systems (>3 levels)
- [ ] Component queries isolated and testable

### 10.2 Functionality

- [ ] All old tests pass (via adapter)
- [ ] New ECS tests pass
- [ ] Full tick runs end-to-end
- [ ] Snapshot format matches old-style
- [ ] WebSocket broadcasts work correctly

### 10.3 Performance

- [ ] Tick time ≤ old-style baseline (goal: ≤ 1.1x)
- [ ] Memory overhead ≤ 20%
- [ ] No performance regressions in hot paths

### 10.4 Maintainability

- [ ] Clear separation between systems
- [ ] Easy to add new components/entities
- [ ] Easy to add new systems
- [ ] Documentation complete

---

## 11. Timeline & Milestones

**Week 1**: Foundation (Phase 1)
- [ ] Add missing components
- [ ] Update entity factories
- [ ] Update adapter
- [ ] Tile key compatibility layer

**Week 2-3**: Systems Implementation (Phase 2)
- [ ] World systems (trees, fruits, structures)
- [ ] Agent systems (actions, mortality)
- [ ] Job systems (generate, assign, progress, complete)
- [ ] Social systems (communication, memory)

**Week 4**: Integration (Phase 3)
- [ ] Tick manager orchestration
- [ ] Wire systems in execution order
- [ ] Integration tests

**Week 5-6**: Gradual Rollout (Phase 4)
- [ ] Replace systems one-by-one with feature flags
- [ ] Verify behavior matches old-style
- [ ] Remove old-style code

**Week 7**: Cleanup (Phase 5)
- [ ] Remove deprecated code
- [ ] Performance optimization
- [ ] Documentation updates

---

## 12. References

- **Brute Entity Library**: https://github.com/Raynes/brute
- **ECS Patterns**: https://github.com/SanderMertens/ecs-framework
- **Current Code**: 
  - `backend/src/fantasia/sim/ecs/core.clj`
  - `backend/src/fantasia/sim/ecs/components.clj`
  - `backend/src/fantasia/sim/ecs/systems/*.clj`
  - `backend/src/fantasia/sim/agents.clj`
  - `backend/src/fantasia/sim/jobs.clj`

---

**Document Version**: 1.0
**Last Updated**: 2026-01-20
**Status**: Ready for Phase 1 Implementation
